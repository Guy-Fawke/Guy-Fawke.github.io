{"posts":[{"title":"基于socket的S/C计算器","content":" 这两天属实是非常的忙，而且干的都是搬砖的活，说自己有一些收货吧，感觉又没学到什么，毕竟是东拼西凑，说自己什么都没学到吧，有感觉还是懂得了一些东西的。这两天终于是抽空看了会书，感触比较深的就是这个基于简单socket的计算器。当然，只是简单的实现了个小的加减乘，本来也不是为了练习计算，而是 从头学习Socket连接。 这里先贴上代码，具体内容里面是有注释的，所以不做过多的解释。 服务器： /*********************************************************************** **Project : Remote_Calculator **author : Guy_Fawkes **Time : 2020.03.06 ***********************************************************************/ #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;winsock2.h&gt; /********************计算函数**********************************/ //因为计算部分并不是重点。这里只是最简单的实现了一下而已 int calculate(int number_of_calculate, int opnds[], char op) { int result = opnds[0], i; switch (op) { case '+': for (i = 1; i &lt; number_of_calculate; i++) result += opnds[i]; break; case '-': for (i = 1; i &lt; number_of_calculate; i++) result -= opnds[i]; break; case '*': for (i = 1; i &lt; number_of_calculate; i++) result *= opnds[i]; break; } return result; } int main() { // 声明所需的变量，内容包括两个SDOCKET 和一个 WSAdata // 两个地址和一个地址长度，这是个人习惯，不一定要一致 SOCKET Slisten, Saccept; WSADATA wsaData; SOCKADDR_IN servAddr, clntAddr; int szClintAddr; // 首先启动socket if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) { printf(&quot;WSAstart up Filed!!\\n&quot;); return 0; } // 建立监听套接字 Slisten = socket(AF_INET, SOCK_STREAM, 0); if (Slisten == INVALID_SOCKET) { printf(&quot;socket() Error !!\\n&quot;); return 0; } // 初始化地址内容 memset(&amp;servAddr, 0, sizeof(servAddr)); servAddr.sin_family = AF_INET; servAddr.sin_addr.s_addr = htonl(INADDR_ANY); servAddr.sin_port = htons(4567); // 将地址内容和socket绑定 if (bind(Slisten, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) == SOCKET_ERROR) { printf(&quot;bind socket Error\\n&quot;); return 0; } // 设定监听队列 if (listen(Slisten, 2) == SOCKET_ERROR) { printf(&quot;listen Error!!&quot;); return 0; } // 开启循环接受链接队列中的内容，尝试进行数据处理 szClintAddr = sizeof(servAddr); char buff[1024]; while (true) { // 建立接受套接字 Saccept = accept(Slisten, (SOCKADDR*)&amp;servAddr, &amp;szClintAddr); if (Saccept == SOCKET_ERROR) { printf(&quot;accept() Error&quot;); return 0; } // 第一步，接受要运算的数字个数 char number_of_calculate ; recv(Saccept, (char *)&amp;number_of_calculate, 1, 0); /*循环接受要计算的内容，这里实现的方法是比较多的 我还是选择了跟书上较为相似的一种方式进行 主要内容是recv函数的第二个参数，也就是接受地址的起始位置*/ int recLength = 0; while ((number_of_calculate * 4 +1)&gt;recLength) { int nRcve = recv(Saccept, &amp;buff[recLength], 1024, 0); recLength += nRcve; } //进行简单的计算并传递回去 int result = calculate(number_of_calculate, (int *)buff, buff[recLength - 1]); send(Saccept, (char*)&amp;result, sizeof(result), 0); closesocket(Saccept); } closesocket(Slisten); WSACleanup(); return 0; } 客户端： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;winsock2.h&gt; int main() { SOCKET Csocket; WSADATA WSAData; SOCKADDR_IN client_addr; if (WSAStartup(MAKEWORD(2, 2), &amp;WSAData) != 0) { printf(&quot;WSAstartUp Error !!!\\n&quot;); return 0; } memset(&amp;client_addr, 0, sizeof(client_addr)); client_addr.sin_family = AF_INET; client_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); client_addr.sin_port = htons(4567); Csocket = socket(AF_INET, SOCK_STREAM, 0); if (Csocket == SOCKET_ERROR) { OutputDebugStringA(&quot;socket Error!!&quot;); return 0; } if (connect(Csocket,(SOCKADDR*)&amp;client_addr,sizeof(client_addr))== SOCKET_ERROR) { OutputDebugStringA(&quot;connect socket error&quot;); return 0; } //之前的内容基本和服务器相似，不做过多解释和记录 char buff[1024]; int number; printf(&quot;Number of Numbers to calculate:&quot;); scanf_s(&quot;%d&quot;, &amp;number); //在第一个字节处存储参与运算的数字个数 buff[0] = (char)number; for (int i=0;i&lt;number;i++) { printf(&quot; operand %d:&quot;, i + 1); //以int类型向buff中存储数字，每次开头的地址是之后的第五个字节 //也就是说，从第二个字节开始，每隔四个字节存入一个运算数 scanf_s(&quot;%d&quot;, (int *)&amp;buff[i * 4 + 1]); } printf(&quot;Input operator:&quot;); //（+1）为第一个 记录个数的char （number*4）是操作数的地址 //在最后的位置存入运算符 scanf_s(&quot;%c&quot;, &amp;buff[(number * 4 + 1)]); //发送输入的内容，大小为 数字个数*4 + 两个char send(Csocket, buff, (number * 4 + 2), 0); // 等待接收结果,设计直接以一个整型接收 int result; recv(Csocket, (char*)&amp;result, 4, 0); //打印结果关闭套接字 printf(&quot;Operation Result is : %d\\n&quot;, result); closesocket(Csocket); WSACleanup(); return 0; } 其实在这个客户端中输入是有讲究的，因为输入的内容是一个只有一字节的运算个数N，和N个【int】（我的是四字节）四字节的运算数，和一个char类型的运算码，我写的时候也没有多想，就直接按照之前的想法进行了，但是在最后运行测试的时候是出现了一些问题的。 对，大家应该很容易能看出来，就是在输入最后一个运算数的时候，我的运算码必须紧跟着输入，这个原因是因为我没有考虑换行符其实是会占位置的，所以在格式化输入的时候自动读取了第三个操作数之后的一个字节的内容，如果之后跟的是换行符的话是会自动填入这个地址中的，因为我觉得这是个收获也是个提醒，所以并没有以对这里进行修改。 传输时的内存空间 这里以我拙劣的画技，简单以两个操作数 “1”，“2” 进行加法运算为例，简单的画出了传输时的布局图，这里虽然最终是用的一个char数组进行的传递，但是其中包含的操作数是以int来存储的，仔细想一下还是比较有意思的。 总结 简单总结一下这个学习内容，首先就是简单的Socket，看书的时候感觉自己确实是都看懂了，但是合上书本自己动手写的时候，确实还是非常难受的，总会在各种细节方面出现意想不到的问题； 第二点也是让我收获最大的一点，就是传输时的内存空间，让我明白了一个道理：**计算机并不需要知道函数传入或者你输入的是什么类型什么格式，你只要能让它明白在哪个地址，按多少位进行读取，一共读取多长。**只要这一点设定好了，不管最终类型是什么样的，总是能够正确的使用这些内容； 最后一点就是，对于计算机来说，不管是渗透测试还是学习其他的内容，最终都会回归编程，最终都会回归到最基础的内容。网络编程就要确实理解计算机网络，理解TCP/IP，其他编程最终都逃不过汇编语言，躲不开操作系统，所以基础知识自己还是需要不断地去学习和巩固。 ","link":"https://guy-Fawke.github.io/post/Socket/"},{"title":"文件上传漏洞之客户端检测绕过","content":" 这里不得不提一下，就目前大家电脑知识普遍提升的情况下，前端的检测显得越来越苍白无力了……不过作为文件上传漏洞的最基础问题，还是非常值得入门时了解学习的。这里的客户端检测仅指针对文件上传这一问题而言的，不用想太多。 对于客户端的概念就不做过多解释了，如果你不想仔细了解，这里就把它当做你的浏览器就可以了，所以此时这个问题就转换成了你自己的浏览器，对你上传的文件进行检测。这不就变成了自己对自己的检查嘛！！!所以之前说这项检测说到底并没有什么*用。 今天以Upload-Labs (也就是一个文件上传漏洞学习的集合)的第一关为例进行学习，解题方法并不是唯一的，这里我们主要是用来学习最基础的这种概念和方式。首先根据提示我们可以很清楚的知道这是一个客户端使用Js对不合法的图片进行的检查。抱着学习的态度我们依次上传一个Webshell和一个图片，对其反馈结果做一个简单的对比。 传入一个php文件： 传入一个jpg文件： 此时两种文件的返回结果还是十分明显的，同时这也表现出了一个比较典型的前端检测的方式，那就是弹窗提醒。我们可以很轻松的知道，此时并不需要查看后端代码，也不需要抓包进行修改等，这时候以最应该做的是：看我之前的那篇文章，查看当前页面的源码🤙【手动狗头】。 这里我们着重找到 onsubmit 事件。前端的JavaScript检测绕过主要有两个事件 onchange ： 事件会在域的内容改变时发生，也可用于单选框复选框改变后触发的事件。 onsubmit ：事件会在表单中确认按钮被点击时触发（也就是在表单提交时触发）onsubmit处理函数返回false不会引起表单的提交。 删掉之后再次点击上传，此时由于并没有触发后续的检测函数，所以文件直接上传成功了，也不会有弹窗进行提示和检测。 我们跟进onsubmit触发的checkFile()函数： 可以看到这里是采用的白名单的检测方式，仅仅定义了三个允许上传的文件类型，在有些时候我们同样能找到前端JavaScript代码中对允许上传的文件类型定义的函数，在这里将想要上传的文件函数后缀加入白名单中，也可以实现绕过检测，这道题由于这里是对配置文件进行引用，在白名单部分并不是真正的前端，所以无法修改，如果大家遇到了可以进行尝试。 总结： 文件上传在前端检测方面是比较简单的，因为是自己对自己进行检测，对于前端来说，还有一种非常典型的为，按键或者文本框是灰色的，无法使用，这里没有专门找例子进行讲解，如果在遇到的时候只需要找到对应的前端触发函数进行删除就可以了，同样也非常简单。而这里作为文件上传的第一个学习科目还是容易让人有成就感的，哈哈。 ","link":"https://guy-Fawke.github.io/post/upload_JS/"},{"title":"CTF入门—一场查看网页源代码的博弈","content":" 为什么会有一个这么奇怪的标题呢，这事要从我开始学习Web安全说起。在初学CTF之时询问了大佬们学哪个方面有前途，大佬们的回答千奇百怪，在考虑了我还是更喜欢对着界面看到成效的这种感觉，最终还是决定向Web方向发展一下，所以这就开始了我的渗透测试学习。学习是基于这个网站的---&gt;攻防世界，这里也推荐给大家，可以和自己的小伙伴组建战队，一起学习进步🤜🤛。 今天要说的这场博弈呢，就是这个练习靶场的Web基础题第一题: 这是一道非常基础的题，想要学习Web，首先就要学会的是查看网页的源代码，几种查看网页源代码的方式都十分简单，这里就不过多解释了，简单列出来： 通过点击鼠标右键查看网页源代码。 通过点击鼠标右键查看元素，精准定位到元素位置，同时查看到网页代码。 在地址栏中输入 view-source:+URL查看网页源代码，Eg view-source:http://baidu.com 即可查看百度的页面源码。 点击键盘上的F12，直接查看网页源代码。 这几种查看网页源代码的方式所得到的的结果是有所区别的，用方法4得到的是未经过浏览器解析的网页源代码，其他三种方式是浏览器解析后的网页源代码，这里就不过多解释了，想要具体了解的朋友可以继续再查看相关资料~~（其实百度百度就能明白）~~。 当然，如果故事到这里就结束了未免也太水了一点，拿到Flag之后的我非常好奇，这是怎么做到的呢？为什么禁止了我的鼠标右键呢，不久之后遇到一个页面，也禁止了我使用F12查看源码，这里就让我十分的不开心了，所以就专门去学习了一下如何禁用鼠标右键和F12查看源码，这里记录下来，和大家一起学习。（涉及到一定的前端知识，我也没有系统学过，可能不能写的很清楚）。 （一）、禁止使用鼠标： &lt;script&gt; function stop(){ return false; } document.documentElement.oncontextmenu=stop; document.documentElement.ondragstart=stop; document.documentElement.onselectstart=stop; &lt;/script&gt; 简单进行解释如下： 首先介绍一个概念 Document对象 当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 简答来说，当你浏览网页的时候，你所操纵的浏览器对于这个网页来说就是一个Document对象。 ​ 其次解释之后的三个事件 oncontextmenu ：当点击右击鼠标时执行 JavaScript ondragstart ：当开始拖动元素时执行JavaScript onselectstart ：触发时间为目标对象被开始选中时（即选中动作刚开始，尚未实质性被选中） 显然，当发生这三个事件的时候会调用stop()，进而返回一个False，这里包括鼠标右键点击和左键选中，所以会使得我们无法使用鼠标（包括左右键），于此类似的还有下面这段代码： &lt;script language=&quot;JavaScript&quot;&gt; document.oncontextmenu=new Function(&quot;event.returnValue=false;&quot;); document.onselectstart=new Function(&quot;event.returnValue=false;&quot;); &lt;/script&gt; （二）、禁止使用F12查看源代码 这里使用的方式和之前大致一样，就是对按键的禁用，只需要在按下F12时将它的按键码转换为 0 即可，展示代码: &lt;script type=&quot;text/javascript&quot;&gt; document.onkeydown = function () { if (window.event &amp;&amp; window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; &lt;/script&gt; 从这个事件的名字我们显而易见onkeydown： onkeydown 事件会在用户按下一个键盘按键时发生。 至于判断条件内的keyCode: keyCode 属性返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 值得一提的是，字符代码和键代码是有所区别的，两种类型的值不是都相等的，比如说小写字符 &quot;w&quot; 和大写字符 &quot;W&quot; 有相同的键盘代码，因为他们键盘上的同一个位置 ( &quot;W&quot; 代码为 &quot;87&quot;)，但是它们有不同的字符代码，两个字符输出是不一样的( &quot;w&quot; 和 &quot;W&quot; 字符代码为 &quot;119&quot; 和 &quot;87&quot;)，这里有个建议，如果需要知道用户按下的是有明显输入内容，不太需要区分大小的打印键 (如 &quot;a&quot; 或 &quot;5&quot;)，建议使用 onkeypress 事件。如果需要知道用户按下的是功能键(如 &quot;F12&quot;, &quot;Home&quot;) 可使用 onkeydown 或 onkeyup 事件，这样可以在按下的瞬间或者松开的瞬间执行。 下面贴上键码对照表（可能有一丢丢不清楚，可以百度直接搜索）： ","link":"https://guy-Fawke.github.io/post/查看源码博弈/"},{"title":" 使用Gridea基于GitHub搭建自己的博客","content":" 思考良久，决定第一篇还是记录一下自己创建博客的过程。很久之前就想有个自己的博客了，用来记录自己的学习过程，写在其他平台那些花里胡哨的广告自己又十分的不喜欢，这两天终于努努力把它实现了。其中搜索了一些资料但是也踩了很多坑，所以这里记录下来，也为以后需要的人提供经验。当然了，初次写文章，可能还会比较混乱，我也会多加努力，一步步做到更好。 我选的这个方式呢应该说是最简单的一种了，基本上点点鼠标就能实现，不足之处就是没有太多自己创造的方面，当然如果你有一定的前端能力，也是可以一点点扩展的。但如果你跟我一样只是需要一个能写文章的地方，而且没有太强的前端技能，那这种方式会很适合你。 一、建立自己的Github账号和仓库 因为实第一篇文章，当然要从最简单的开始讲起，所以我们先开始建立一个Github账号并建立一个仓库。这种时候你只需要点击这里---&gt;Github直通车 之后会有一个简单的人机认证，和选择付费还是免费的内容，这里大多数情况下使用免费的Github就能够满足大家的使用要求了。最后只需要根据自己的情况很轻松你就能拥有一个自己的Github账号了。 有了账号之后当然是要创建一个Repositories，也就是一个仓库来存储自己博客，点击这里的New。 接着写下自己的仓库名，我的已经建立了所以会报错，这里按照建议填的话会比较方便，这样Github会自动建立一个GitHub Pages会更为方便 (我承认我比较懒) ，当然也算是我不小心踩到的一个坑，如果只是一个空仓库的话他不会建立分支和其他内容，就需要自己去设置里将这个仓库变为一个GitHub pages，在这就不过多解释了， 接下来就可以轻松的开始我们的第二步了。 二、生成Token和生成页面 这里我也是看着别人学习的，大佬写的非常的详细所以把大佬的教学博客贴过来供大家学习和参考，同时当做自己的学费----&gt;&gt; 看搭建过程点这里！！！ 这篇文章的最后有其他的一些搭建方式，所以如果想学习了解，或者完全自主的搭建自己的博客的话，可以看他最下面推荐的几种方式。 我主要想写一个非常大的坑，如果不看上面的教程可能会有点莫名其妙。 在这里检测远程连接的时候，很多人即使填对了所有的信息之后也容易一直连接失败，我因为这个问题搞了很久很久，甚至陷入了对自己深深的怀疑……如果你确定所有信息尤其是Token没有填错的话，就可以继续往下看了。 ------------------听说在新发布的最新版已经更正了错误，不知道还有没有用----------------- 1. 去自己的Github仓库复制你的git连接。 2. 找到Gridea的文件夹（一般在文档下面），找到output文件夹打开 3. 空白处右键打开Git Bash 4. 输入以下命令回车 git remote add origin &quot;仓库的git命令地址&quot; (只是一个命令就不贴图啦)之后再返回点击远程测试，如果不出意外的话就能成功连接了。 总结 我也是这两天刚刚开始使用Gridea并且搭建起了自己的博客，总体来说过程磕磕绊绊但是结果还是很好的。这个软件还比较小众，内在的设计大家可以自己再去没事点一点研究一下，如果有好的使用技巧也欢迎能够分享。我个人认为，有一点不足就是我不知道为什么目前没办法用其他的Markdown编译器来写自己的博客，后续如果成功了还会再来更新自己的使用方法，这里当然要推荐我比较喜欢的一款编辑器啦！！Typora 边写边预览，小巧又轻便，哈哈，和我用来搭建博客的软件一样哦。 ","link":"https://guy-Fawke.github.io/post/Make_Gridea/"}]}